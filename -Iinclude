# 1 "src/AgileFrontiers/10-Playfield/Actor.ts"
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 399 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "src/AgileFrontiers/10-Playfield/Actor.ts" 2

namespace AgileFrontiers {
    export namespace Playfield {
        import Rect = AgileFrontiers.Graphics.Rect;
        import GfxParms = AgileFrontiers.Graphics.GfxParms;

        export class Actor implements Tree {
            public rect: Rect;
            public draggable: Draggable;
            public eventHandler: EventHandler;
            public isSelected: boolean;
            public hasFocus: boolean;
            public logger: Logger;
            private playfield: Playfield;
            public gparms = new GfxParms();

            public parent: any;
            public name: string;
            public obj: any;
            public children: Tree[];
        
            Tree(name: string) {
                this.name = name;
                this.children = [];
            }
            add(obj: Tree) {
                obj.parent = this;
                this.children.push(obj);
            }
            dfs(visit: (obj: Tree, ctx: any) => any, ctx?: any): boolean {
                let stop = visit(this, ctx);
                if (stop) return stop;
                for (let child of this.children) {
                    stop = child.dfs(visit, ctx);
                    if (stop) return stop;
                }
            }
                
            constructor(parent: Playfield | Actor, name: string, x: number, y: number, w: number, h: number) {
                this.rect = new Rect(x, y, w, h);
                this.logger = new Logger("Actor", "warn");
                this.eventHandler = null;
                parent.add(this);
            }
            get X(): number {
                return this.rect.x + this.gparms.xOffset;
            }
            get Y(): number {
                return this.rect.y + this.gparms.yOffset;
            }
            // add(obj: Actor) {
            //     this.node.add(obj.node);
            //     obj.playfield = this.node.parent.obj.playfield;
            // }
            move(x: number, y: number, w = this.rect.w, h = this.rect.h): void {
                this.rect.x = x;
                this.rect.y = y;
                this.rect.w = w;
                this.rect.h = h;
            }
            rmove(dx: number, dy: number, dw = 0, dh = 0): void {
                this.rect.x += dx;
                this.rect.y += dy;
                this.rect.w += dw;
                this.rect.h += dh;
            }
            select() {
                this.isSelected = true;
            }
            deselect() {
                this.isSelected = false;
            }
            focus() {
                this.hasFocus = true;
            }
            defocus() {
                this.hasFocus = false;
            }
            inBounds(x: number, y: number): Actor {
                let result =
                    Utils.between(this.gparms.xOffset + this.rect.x, x, this.gparms.xOffset + this.rect.x + this.rect.w) &&
                    Utils.between(this.gparms.yOffset + this.rect.y, y, this.gparms.yOffset + this.rect.y + this.rect.h);
                if (result) return this;
                for (let i = this.children.length - 1; i >= 0; i--) {
                    let obj = this.children[i];
                    let found = (obj.obj as Actor).inBounds(x, y);
                    if (found) return this;
                }
                return null;
            }
            click(x: number, y: number) {
                this.logger.log("CLICK! " + this.name + ": " + x + "," + y);
            }
            keydown(key: string) {
                if (key === "ArrowUp") this.rect.y -= 10;
                if (key === "ArrowDown") this.rect.y += 10;
                if (key === "ArrowLeft") this.rect.x -= 10;
                if (key === "ArrowRight") this.rect.x += 10;
            }
            go(): void {
            }
            recompute() {
                let parentGparms = this.parent.gparms;
                if (parentGparms) {
                    this.gparms.xOffset = this.parent.rect.x + parentGparms.xOffset;
                    this.gparms.yOffset = this.parent.rect.y + parentGparms.yOffset;
                }
            }
            drawAll(): void {
                this.recompute();
                this.draw();
                if (this.children.length) {
                    for (let obj of this.children) {
                        obj.obj.drawAll();
                    }
                }
            }
            draw(): void {
            }
        }
    }
}
